% -*- coding: utf-8; -*-
% vim: set fileencoding=utf-8 :
\documentclass[english,submission]{programming}
%% First parameter: the language is 'english'.
%% Second parameter: use 'submission' for initial submission, remove it for camera-ready (see 5.1)

\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\begin{document}

\title{Wildcard: Modifying web applications by directly manipulating a
data table}
\subtitle{}% optional

\author{Geoffrey Litt}
\authorinfo{is bla bla bla}
\author{Daniel Jackson}
\authorinfo{is bla bla bla}
\affiliation{Massachusetts Institute of Technology}

\keywords{programming journal, paper formatting, submission preparation} % please provide 1--5 keywords


%%%%%%%%%%%%%%%%%%
%% These data MUST be filled for your submission. (see 5.3)
\paperdetails{
  %% perspective options are: art, sciencetheoretical, scienceempirical, engineering.
  %% Choose exactly the one that best describes this work. (see 2.1)
  perspective=art,
  %% State one or more areas, separated by a comma. (see 2.2)
  %% Please see list of areas in http://programming-journal.org/cfp/
  %% The list is open-ended, so use other areas if yours is/are not listed.
  area={Social Coding, General-purpose programming},
  %% You may choose the license for your paper (see 3.)
  %% License options include: cc-by (default), cc-by-nc
  % license=cc-by,
}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%
%% These data are provided by the editors. May be left out on submission.
%\paperdetails{
%  submitted=2016-08-10,
%  published=2016-10-11,
%  year=2016,
%  volume=1,
%  issue=1,
%  articlenumber=1,
%}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Please go to https://dl.acm.org/ccs/ccs.cfm and generate your Classification
% System [view CCS TeX Code] stanz and copy _all of it_ to this place.
%% From HERE
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10002944.10011122.10003459</concept_id>
<concept_desc>General and reference~Computing standards, RFCs and guidelines</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10010405.10010476.10010477</concept_id>
<concept_desc>Applied computing~Publishing</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[300]{General and reference~Computing standards, RFCs and guidelines}
\ccsdesc[500]{Applied computing~Publishing}

% To HERE
%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

% Please always include the abstract.
% The abstract MUST be written according to the directives stated in 
% http://programming-journal.org/submission/
% Failure to adhere to the abstract directives may result in the paper
% being returned to the authors.
\begin{abstract}
Browser extensions and user scripts can modify web applications in
useful ways, but many people have unique needs that aren't met by
existing extensions. Today, most of them are stuck---they can't build
their own browser extensions without learning how to program in
Javascript.

Wildcard is a platform that empowers anyone to build browser extensions
without doing traditional programming. Wildcard shows the main data from
a web page in a table with a bidirectional connection to the original
page. People can directly manipulate the table to sort/filter content,
add private annotations, and use spreadsheet formulas to fetch data from
other websites.
\end{abstract}


\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

Todos for the introduction:

\begin{itemize}
\tightlist
\item
  hook with Airbnb sort
\item
  add more bigger picture reasons, less focus on the affordances
\item
  make this shorter
\end{itemize}

People have complaints about web apps they use, but they rarely modify
those apps to meet their needs. Why not? Some guesses:

\begin{itemize}
\tightlist
\item
  Technical skill: Most people don't know how to use Javascript and
  manipulate the DOM.
\item
  Low ROI: It takes a long time to reverse engineer a site, and it's
  usually not worth it
\end{itemize}

These seem reasonable but they might not tell the whole story.

There have been many research projects that try to address these
hurdles. For example, Chickenfoot \autocite{bolin2005} allows for people
to more quickly modify sites without using Javascript or dealing with
the DOM, directly addressing both of these barriers. But, a decade
later, not many people have ended up using systems like this.

I know how to do web programming, and yet I rarely modify my apps.
Sometimes it actually turns out to be pretty easy to hack on a site once
I start doing it so the ROI is actually pretty high. These reasons don't
seem to fully explain my behavior.

A disheartening explanation might be that most people just don't care
enough to make changes. This claim might be true in the current context,
but it's also important to remember that motivation is connected to
culture and to the space of possibilities provided by our tools. Most
people probably didn't want to write letters before mass literacy.

One interesting explanation is that \textbf{people can't estimate the
difficulty of a change}. It's not motivating to think about what changes
I might want when I don't know whether they would take a few minutes or
are completely impossible. For me, an engineer, this gets at the heart
of the issue. I know I could probably implement the change, but it's so
hard to estimate how long it would take (minutes? months?) that I don't
even bother trying. In general, when something seems expensive to do (or
even possibly expensive), it can discourage casual lightweight
experimentation.

So, perhaps to encourage people to casually modify software,
\textbf{apps need to provide more consistent affordances indicating what
changes are possible and easy.} Maybe if it were more obvious that
certain types of changes could be achieved in mere minutes, programmers
and non-programmers would end up modifying our software more.

\hypertarget{the-wildcard-platform}{%
\subsubsection{The Wildcard platform}\label{the-wildcard-platform}}

Wildcard adds a panel to the bottom of a web page that shows a
structured table view of some of the core data in the page. When the
user manipulates the table, the original page also gets modified. We aim
to make the mapping between the table and the page as direct and
intuitive as possible.

Todos here:

\begin{itemize}
\tightlist
\item
  a better demo is actually sorting too at this point too, to show the
  bidirectional nature
\item
  hint at future possibilities
\item
  introduce an image fallback for the PDF version
\end{itemize}

For example, in Fig.~\ref{fig:table} we open up a table view that
corresponds to search results on the Airbnb travel site.

\begin{figure}
\hypertarget{fig:table}{%
\centering
\includegraphics{media/opentable.png}
\caption{Opening a table corresponding to search results on
Airbnb}\label{fig:table}
}
\end{figure}

Wildcard is fairly general and can support many useful changes to
websites, which will be demoed later:

\begin{itemize}
\tightlist
\item
  sorting and filtering data: eg sorting shopping results
\item
  using 3rd-party APIs and performing small computations to add new
  data, in the style of ``web mashups'': eg adding walkability scores to
  hotel listings
\item
  adding private user annotations to the page: eg taking notes on
  different options
\item
  using alternate UI widgets to enter data into a page: eg using a
  personal datepicker widget with private calendar data, to enter the
  right dates for taking a flight
\end{itemize}

The overall goal is to provide generic tools that fit well with the
table paradigm and enable many specific useful changes. But it's
important to note that Wildcard doesn't aim to provide maximum coverage
all the possible ways someone might want to modify a web page. Rather,
it aims to provide a useful, simple subset of modifications, and to
provide consistent affordances so that users confidently understand
which modifications they can make.

\hypertarget{demo-booking-a-trip-with-wildcard}{%
\section{Demo: Booking a trip with
Wildcard}\label{demo-booking-a-trip-with-wildcard}}

\begin{itemize}
\tightlist
\item
  Sorting search results:

  \begin{itemize}
  \tightlist
  \item
    Airbnb took away search
  \item
    once you see the tabular view, there's an obvious interaction
    available to anyone familiar with tables
  \end{itemize}
\item
  Injecting new data into the page

  \begin{itemize}
  \tightlist
  \item
    Take own custom notes, saved in the browser. Maybe shared in the
    future
  \end{itemize}
\item
  Formulas

  \begin{itemize}
  \tightlist
  \item
    Compute values to inject into the page
  \item
    TBD: styling
  \end{itemize}
\item
  Using a custom date picker
\end{itemize}

\hypertarget{implementation}{%
\section{Implementation}\label{implementation}}

Eventually web apps might provide the structured data table themselves.
In the meantime, we need some sort of adapter to make this system work
with existing sites.

Wildcard provides a system for creating a wrapper on top of existing
websites. This wrapper defines how structured data can be extracted out
of the page, and also how manipulating the table should modify the page.

The most basic way of building these wrappers is for skilled programmers
to manually build and maintain them for popular sites. This approach
beats the status quo because many people, including end users, can
benefit from the generic wrapper and use it in many ways. This is
different from the current world where programmers build
use-case-specific browser extensions, and each extension has to
implement its own interactions with the low-level DOM of a page. There's
also a greater incentive for many people to collectively maintain a
wrapper if it's shared.

A more advanced way would be to make these wrappers partially or totally
automated, and enable end users to create them. This future work could
leverage existing research on wrapper induction but isn't the focus of
the current work.

\hypertarget{design-principles}{%
\section{Design principles}\label{design-principles}}

Here are some of the ideas behind the design of Wildcard. We hope these
can be useful principles not only for Wildcard, but also for other tools
that enable end users to modify software.

\hypertarget{expose-unified-structure-across-applications}{%
\subsection{Expose unified structure across
applications}\label{expose-unified-structure-across-applications}}

In \emph{Changing Minds} \autocite{disessa2000}, Andrea diSessa
critiques the design of modern software with a story about a
hypothetical ``nightmare bike.'' Each gear on the nightmare bike is
labeled not with a number, but with an icon describing its intended use:
smooth pavement uphill, smooth pavement downhill, gravel, etc. By some
logic, this is more ``user-friendly'' than numbered gears, but in fact,
hiding orderly structure from the user makes it more difficult to
operate the bike. Many modern software designs fall into this trap,
teaching users to use isolated modes rather than coherent structure, and
the problem gets far worse when operating across multiple applications.
Unlike the UNIX philosophy of small tools interoperating through shared
abstractions, in modern computing each application is in its own silo of
data and functionality.

Wildcard helps people understand and modify the behavior of applications
through the lens of a consistent abstraction: a data table. This
abstraction strikes a balance between being both simple and generic. A
data table is simpler than the DOM tree that describes the details of
the UI, but is also generic enough to describe the essence of many
different kinds of applications.

Exposing a unified higher-level abstraction is a deliberate choice, and
is not the only way to enable users to program without directly using
the DOM. Chickenfoot \autocite{bolin2005} and CoScripter
\autocite{leshed2008} allow users to create scripts that resemble
natural language and ``sloppily'' match queries to elements in the DOM.
These designs allow for a wide range of operations, but don't explicitly
indicate what operations are possible---the user must look at the
original page and imagine the possibilities. In contrast, Wildcard
provides affordances that clearly suggest the availability of certain
types of modifications. In addition to giving users more certainty about
whether a modification is possible, these affordances might give users
new ideas for things to try. Because people are not used to modifying
web applications, providing inspiration is an important goal. (Todo:
Perhaps something to cite here, re: discoverability in GUIs vs CLIs?)

\hypertarget{direct-manipulation-by-proxy}{%
\subsection{Direct manipulation by
proxy}\label{direct-manipulation-by-proxy}}

In Wildcard, users don't interact with the original page to modify it;
instead they manipulate an alternate representation of the data in the
page. The tool uses visual cues to indicate the mapping between the
table representation and the original page. This is similar to the way
that browser developer tools use in-page highlighting to indicate the
mapping between HTML and the original page.

\begin{figure}
\hypertarget{fig:devtools}{%
\centering
\includegraphics{media/devtools.png}
\caption{The Chrome Dev Tools use highlighting to show the mapping
between HTML code and the page}\label{fig:devtools}
}
\end{figure}

We considered alternate approaches where the user would interact more
directly with the original page, but decided that the table view
provided a consistent

\begin{itemize}
\tightlist
\item
  True DM might be right on the page itself

  \begin{itemize}
  \tightlist
  \item
    There are good UIs for this, eg Chrome DevTools element picker
  \end{itemize}
\item
  Considered for Wildcard, but went with an indirect proxy. Still
  maintain a close mapping.
\item
  Pros: consistency across sites. Avoid site-specific styling issues.
\item
  Cons: maybe less intuitive? More work to do the mapping, might be a
  source of confusion.
\end{itemize}

\hypertarget{first-party-optional}{%
\subsection{First party optional}\label{first-party-optional}}

\begin{itemize}
\tightlist
\item
  3p-only is enough. 1p help is optional.
\item
  Can even do things the 1p didn't want to expose.
\item
  make it easy for 1p: just ask for a data table, no fancy schema.
\end{itemize}

\hypertarget{built-for-the-web}{%
\subsection{Built for the web}\label{built-for-the-web}}

\begin{itemize}
\tightlist
\item
  web has the right foundations:

  \begin{itemize}
  \tightlist
  \item
    the right platform
  \item
    open platform
  \item
    dev tools
  \item
    originally intended to be
  \end{itemize}
\item
  in-place toolchain: meet the user where they are, in the page
\end{itemize}

\hypertarget{decouple-ui-from-data}{%
\subsection{Decouple UI from data}\label{decouple-ui-from-data}}

\begin{itemize}
\tightlist
\item
  bring your own views of the data
\item
  bring your own widgets for data entry
\item
  instrumental interaction
\end{itemize}

\hypertarget{related-work}{%
\section{Related work}\label{related-work}}

\begin{itemize}
\tightlist
\item
  Instrumental interaction
\item
  Web automation
\item
  Wrapper induction
\item
  Personal data
\item
  Extension helpers
\end{itemize}

\hypertarget{future-work}{%
\section{Future work}\label{future-work}}

\begin{itemize}
\tightlist
\item
  How far does functionality go?

  \begin{itemize}
  \tightlist
  \item
    workflows? triggers?
  \item
    what can and can't be done
  \end{itemize}
\item
  automated wrappers?

  \begin{itemize}
  \tightlist
  \item
    lean on existing tech
  \end{itemize}
\item
  usability studies
\end{itemize}

\hypertarget{meta-todos}{%
\section{meta: todos}\label{meta-todos}}

\begin{itemize}
\tightlist
\item
  remove bold text for the proceedings version
\item
  go through the Programming proceedings template checklist
\end{itemize}

\acks
\printbibliography

\end{document}

% Local Variables:
% TeX-engine: luatex
% End:
