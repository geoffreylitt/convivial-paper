
@inproceedings{bolin2005,
  address = {{Seattle, WA, USA}},
  title = {Automation and Customization of Rendered Web Pages},
  isbn = {978-1-59593-271-6},
  abstract = {On the desktop, an application can expect to control its user interface down to the last pixel, but on the World Wide Web, a content provider has no control over how the client will view the page, once delivered to the browser. This creates an opportunity for end-users who want to automate and customize their web experiences, but the growing complexity of web pages and standards prevents most users from realizing this opportunity. We describe Chickenfoot, a programming system embedded in the Firefox web browser, which enables end-users to automate, customize, and integrate web applications without examining their source code. One way Chickenfoot addresses this goal is a novel technique for identifying page components by keyword pattern matching. We motivate this technique by studying how users name web page components, and present a heuristic keyword matching algorithm that identifies the desired component from the user's name.},
  language = {en},
  booktitle = {Proceedings of the 18th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology  - {{UIST}} '05},
  publisher = {{ACM Press}},
  doi = {10.1145/1095034.1095062},
  author = {Bolin, Michael and Webber, Matthew and Rha, Philip and Wilson, Tom and Miller, Robert C.},
  year = {2005},
  keywords = {Wildcard},
  pages = {163},
  file = {/Users/geoffreylitt/Zotero/storage/JS89G2G2/Bolin et al. - 2005 - Automation and customization of rendered web pages.pdf}
}

@book{disessa2000,
  address = {{Cambridge, MA, USA}},
  title = {Changing {{Minds}}: {{Computers}}, {{Learning}}, and {{Literacy}}},
  shorttitle = {Changing {{Minds}}},
  publisher = {{MIT Press}},
  author = {{diSessa}, Andrea A.},
  year = {2000}
}

@inproceedings{leshed2008,
  address = {{Florence, Italy}},
  series = {{{CHI}} '08},
  title = {{{CoScripter}}: {{Automating}} \& {{Sharing How}}-to {{Knowledge}} in the {{Enterprise}}},
  isbn = {978-1-60558-011-1},
  shorttitle = {{{CoScripter}}},
  abstract = {Modern enterprises are replete with numerous online processes. Many must be performed frequently and are tedious, while others are done less frequently yet are complex or hard to remember. We present interviews with knowledge workers that reveal a need for mechanisms to automate the execution of and to share knowledge about these processes. In response, we have developed the CoScripter system (formerly Koala [11]), a collaborative scripting environment for recording, automating, and sharing web-based processes. We have deployed CoScripter within a large corporation for more than 10 months. Through usage log analysis and interviews with users, we show that CoScripter has addressed many user automation and sharing needs, to the extent that more than 50 employees have voluntarily incorporated it into their work practice. We also present ways people have used CoScripter and general issues for tools that support automation and sharing of how-to knowledge.},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  publisher = {{ACM}},
  doi = {10.1145/1357054.1357323},
  author = {Leshed, Gilly and Haber, Eben M. and Matthews, Tara and Lau, Tessa},
  year = {2008},
  keywords = {automation,knowledge sharing,procedural knowledge,programming-by-demonstration,scripting,user study,wiki},
  pages = {1719--1728},
  file = {/Users/geoffreylitt/Zotero/storage/RHE55DIG/Leshed et al. - 2008 - CoScripter Automating & Sharing How-to Knowledge .pdf}
}

@misc{talwar2019,
  title = {Gmail.Js},
  abstract = {Gmail JavaScript API},
  language = {en},
  journal = {GitHub},
  howpublished = {https://github.com/KartikTalwar/gmail.js},
  author = {Talwar, Kartik},
  year = {2019},
  file = {/Users/geoffreylitt/Zotero/storage/EQIGCWJM/master.html}
}

@misc{streak,
  title = {{{InboxSDK}}},
  howpublished = {https://www.inboxsdk.com/},
  author = {Streak},
  file = {/Users/geoffreylitt/Zotero/storage/TK2FCLM5/www.inboxsdk.com.html}
}

@misc{inkandswitch2019,
  title = {End-User Programming},
  abstract = {A vision for empowered computing that reaches back forty years. Our research lab examines why it has been so hard to achieve.},
  language = {en-US},
  journal = {Ink and Switch},
  author = {{Ink {and} Switch}},
  month = mar,
  year = {2019},
  file = {/Users/geoffreylitt/Zotero/storage/VN9ZZWVZ/end-user-programming.html}
}

@inproceedings{beaudouin-lafon2000,
  address = {{Palermo, Italy}},
  series = {{{AVI}} '00},
  title = {Reification, {{Polymorphism}} and {{Reuse}}: {{Three Principles}} for {{Designing Visual Interfaces}}},
  isbn = {978-1-58113-252-6},
  shorttitle = {Reification, {{Polymorphism}} and {{Reuse}}},
  abstract = {This paper presents three design principles to support the development of large-scale applications and take advantage of recent research in new interaction techniques: Reification turns concepts into first class objects, polymorphism permits commands to be applied to objects of different types, and reuse makes both user input and system output accessible for later use. We show that the power of these principles lies in their combination. Reification creates new objects that can be acted upon by a small set of polymorphic commands, creating more opportunities for reuse. The result is a simpler yet more powerful interface.
To validate these principles, we describe their application in the redesign of a complex interface for editing and simulating Coloured Petri Nets. The cpn2000 interface integrates floating palettes, toolglasses and marking menus in a consistent manner with a new metaphor for managing the workspace. It challenges traditional ideas about user interfaces, getting rid of pull-down menus, scrollbars, and even selection, while providing the same or greater functionality. Preliminary tests with users show that they find the new system both easier to use and more efficient.},
  booktitle = {Proceedings of the {{Working Conference}} on {{Advanced Visual Interfaces}}},
  publisher = {{ACM}},
  doi = {10.1145/345513.345267},
  author = {{Beaudouin-Lafon}, Michel and Mackay, Wendy E.},
  year = {2000},
  keywords = {design principles,direct manipulation,instrumental interaction,interaction model,polymorphism,reification,reuse},
  pages = {102--109},
  file = {/Users/geoffreylitt/Zotero/storage/ZUTWDQ9X/Beaudouin-Lafon and Mackay - 2000 - Reification, Polymorphism and Reuse Three Princip.pdf}
}

@misc{berners-lee2018,
  title = {One {{Small Step}} for the {{Web}}\ldots{}},
  abstract = {I've always believed the web is for everyone. That's why I and others fight fiercely to protect it. The changes we've managed to bring have\ldots{}},
  language = {en},
  journal = {Medium},
  howpublished = {https://medium.com/@timberners\_lee/one-small-step-for-the-web-87f92217d085},
  author = {{Berners-Lee}, Tim},
  month = sep,
  year = {2018},
  file = {/Users/geoffreylitt/Zotero/storage/MSSQR3BL/one-small-step-for-the-web-87f92217d085.html}
}

@inproceedings{klokmose2015,
  address = {{Daegu, Kyungpook, Republic of Korea}},
  title = {Webstrates: {{Shareable Dynamic Media}}},
  isbn = {978-1-4503-3779-3},
  shorttitle = {Webstrates},
  abstract = {We revisit Alan Kay's early vision of dynamic media that blurs the distinction between documents and applications. We introduce shareable dynamic media that are malleable by users, who may appropriate them in idiosyncratic ways; shareable among users, who collaborate on multiple aspects of the media; and distributable across diverse devices and platforms. We present Webstrates, an environment for exploring shareable dynamic media. Webstrates augment web technology with real-time sharing. They turn web pages into substrates, i.e. software entities that act as applications or documents depending upon use. We illustrate Webstrates with two implemented case studies: users collaboratively author an article with functionally and visually different editors that they can personalize and extend at run-time; and they orchestrate its presentation and audience participation with multiple devices. We demonstrate the simplicity and generative power of Webstrates with three additional prototypes and evaluate it from a systems perspective.},
  language = {en},
  booktitle = {Proceedings of the 28th {{Annual ACM Symposium}} on {{User Interface Software}} \& {{Technology}} - {{UIST}} '15},
  publisher = {{ACM Press}},
  doi = {10.1145/2807442.2807446},
  author = {Klokmose, Clemens N. and Eagan, James R. and Baader, Siemen and Mackay, Wendy and {Beaudouin-Lafon}, Michel},
  year = {2015},
  pages = {280-290},
  file = {/Users/geoffreylitt/Zotero/storage/PZI6XAMQ/Klokmose et al. - 2015 - iWebstratesi Shareable Dynamic Media.pdf}
}

@article{kay1977,
  title = {Personal {{Dynamic Media}}},
  volume = {10},
  issn = {1558-0814},
  abstract = {The Learning Research Group at Xerox Palo Alto Research Center is concerned with all aspects of the communication and manipulation of knowledge. We design, build, and use dynamic media which can be used by human beings of all ages. Several years ago, we crystallized our dreams into a design idea for a personal dynamic medium the size of a notebook (the Dynabook) which could be owned by everyone and could have the power to handle virtually all of its owner's information-related needs. Towards this goal we have designed and built a communications system: the Smalltalk language, implemented on small computers we refer to as "interim Dynabooks." We are exploring the use of this system as a programming and problem solving tool; as an interactive memory for the storage and manipulation of data; as a text editor; and as a medium for expression through drawing, painting, animating pictures, and composing and generating music. (Figure 1 is a view of this interim Dynabook.)},
  number = {3},
  journal = {Computer},
  doi = {10.1109/C-M.1977.217672},
  author = {Kay, A. and Goldberg, A.},
  month = mar,
  year = {1977},
  keywords = {Animation,Computational modeling,Crystallization,Embedded computing,Information retrieval,Manipulator dynamics,Problem-solving},
  pages = {31-41},
  file = {/Users/geoffreylitt/Zotero/storage/Q3SGCHYI/Kay and Goldberg - 1977 - Personal Dynamic Media.pdf;/Users/geoffreylitt/Zotero/storage/8Q36BUGB/1646405.html}
}

@article{chang2019,
  title = {Dependent Type Systems as Macros},
  volume = {4},
  issn = {24751421},
  language = {en},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  doi = {10.1145/3371071},
  author = {Chang, Stephen and Ballantyne, Michael and Turner, Milo and Bowman, William J.},
  month = dec,
  year = {2019},
  keywords = {toread},
  pages = {1-29},
  file = {/Users/geoffreylitt/Zotero/storage/DL7ZUBWU/Chang et al. - 2019 - Dependent type systems as macros.pdf}
}

@article{lew2019,
  title = {Trace Types and Denotational Semantics for Sound Programmable Inference in Probabilistic Languages},
  volume = {4},
  issn = {24751421},
  abstract = {ALEXANDER K. LEW, Massachusetts Institute of Technology, USA MARCO F. CUSUMANO-TOWNER, Massachusetts Institute of Technology, USA BENJAMIN SHERMAN, Massachusetts Institute of Technology, USA MICHAEL CARBIN, Massachusetts Institute of Technology, USA VIKASH K. MANSINGHKA, Massachusetts Institute of Technology, USA Modern probabilistic programming languages aim to formalize and automate key aspects of probabilistic modeling and inference. Many languages provide constructs for programmable inference that enable developers 19 to improve inference speed and accuracy by tailoring an algorithm for use with a particular model or dataset. Unfortunately, it is easy to use these constructs to write unsound programs that appear to run correctly but produce incorrect results. To address this problem, we present a denotational semantics for programmable inference in higher-order probabilistic programming languages, along with a type system that ensures that well-typed inference programs are sound by construction. A central insight is that the type of a probabilistic expression can track the space of its possible execution traces, not just the type of value that it returns, as these traces are often the objects that inference algorithms manipulate. We use our semantics and type system to establish soundness properties of custom inference programs that use constructs for variational, sequential Monte Carlo, importance sampling, and Markov chain Monte Carlo inference. CCS Concepts: {$\cdot$} Mathematics of computing \textrightarrow{} Probabilistic inference problems; Variational methods; Metropolis-Hastings algorithm; Sequential Monte Carlo methods; {$\cdot$} Theory of computation \textrightarrow{} Semantics and reasoning; Denotational semantics; {$\cdot$} Software and its engineering \textrightarrow{} Formal language definitions.},
  language = {en},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  doi = {10.1145/3371087},
  author = {Lew, Alexander K. and {Cusumano-Towner}, Marco F. and Sherman, Benjamin and Carbin, Michael and Mansinghka, Vikash K.},
  month = dec,
  year = {2019},
  keywords = {toread},
  pages = {1-32},
  file = {/Users/geoffreylitt/Zotero/storage/RTHTYZ7Y/Lew et al. - 2019 - Trace types and denotational semantics for sound p.pdf}
}

@article{wang2019,
  title = {Visualization by Example},
  volume = {4},
  issn = {24751421},
  abstract = {CHENGLONG WANG, University of Washington, USA YU FENG, University of California, Santa Barbara, USA RASTISLAV BODIK, University of Washington, USA ALVIN CHEUNG, University of California, Berkeley, USA ISIL DILLIG, University of Texas at Austin, USA While visualizations play a crucial role in gaining insights from data, generating useful visualizations from a complex dataset is far from an easy task. In particular, besides understanding the functionality provided by existing visualization libraries, generating the desired visualization also requires reshaping and aggregating the underlying data as well as composing different visual elements to achieve the intended visual narrative. This paper aims to simplify visualization tasks by automatically synthesizing the required program from simple visual sketches provided by the user. Specifically, given an input data set and a visual sketch that demonstrates how to visualize a very small subset of this data, our technique automatically generates a program that can be used to visualize the entire data set. From a program synthesis perspective, automating visualization tasks poses several challenges that are not addressed by prior techniques. First, because many visualization tasks require data wrangling in addition to generating plots from a given table, we need to decompose the end-to-end synthesis task into two separate sub-problems. Second, because the intermediate specification that results from the decomposition is necessarily imprecise, this makes the data wrangling task particularly challenging in our context. In this paper, we address these problems by developing a new compositional visualization-by-example technique that (a) decomposes the end-to-end task into two different synthesis problems over different DSLs and (b) leverages bi-directional program analysis to deal with the complexity that arises from having an imprecise intermediate specification. We have implemented our visualization-by-example approach in a tool called Viser and evaluate it on 83 visualization tasks collected from on-line forums and tutorials. Viser can solve 84\% of these benchmarks within a 600 second time limit, and, for those tasks that can be solved, the desired visualization is among the top-5 generated by Viser in 70\% of the cases. CCS Concepts: \textbullet{} Theory of computation \textrightarrow{} Program reasoning; \textbullet{} Human-centered computing \textrightarrow{} Visualization toolkits.},
  language = {en},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  doi = {10.1145/3371117},
  author = {Wang, Chenglong and Feng, Yu and Bodik, Rastislav and Cheung, Alvin and Dillig, Isil},
  month = dec,
  year = {2019},
  keywords = {toread},
  pages = {1-28},
  file = {/Users/geoffreylitt/Zotero/storage/2RWUSYKS/Wang et al. - 2019 - Visualization by example.pdf}
}

@article{ohearn2019,
  title = {Incorrectness Logic},
  volume = {4},
  issn = {24751421},
  abstract = {PETER W. O'HEARN, Facebook and University College London, UK 10 Program correctness and incorrectness are two sides of the same coin. As a programmer, even if you would like to have correctness, you might find yourself spending most of your time reasoning about incorrectness. This includes informal reasoning that people do while looking at or thinking about their code, as well as that supported by automated testing and static analysis tools. This paper describes a simple logic for program incorrectness which is, in a sense, the other side of the coin to Hoare's logic of correctness. CCS Concepts: {$\cdot$} Theory of computation \textrightarrow{} Programming logic.},
  language = {en},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  doi = {10.1145/3371078},
  author = {O'Hearn, Peter W.},
  month = dec,
  year = {2019},
  keywords = {toread},
  pages = {1-32},
  file = {/Users/geoffreylitt/Zotero/storage/TDY592AI/O'Hearn - 2019 - Incorrectness logic.pdf}
}

@inproceedings{mayer2015,
  address = {{Daegu, Kyungpook, Republic of Korea}},
  title = {User {{Interaction Models}} for {{Disambiguation}} in {{Programming}} by {{Example}}},
  isbn = {978-1-4503-3779-3},
  abstract = {Programming by Examples (PBE) has the potential to revo\- lutionize end-user programming by enabling end users, most of whom are non-programmers, to create small scripts for au\- tomating repetitive tasks. However, examples, though often easy to provide, are an ambiguous specification of the user's intent. Because of that, a key impedance in adoption of PBE systems is the lack of user confidence in the correctness of the program that was synthesized by the system. We present two novel user interaction models that communicate action\- able information to the user to help resolve ambiguity in the examples. One of these models allows the user to effectively navigate between the huge set of programs that are consis\- tent with the examples provided by the user. The other model uses active learning to ask directed example-based questions to the user on the test input data over which the user intends to run the synthesized program. Our user studies show that each of these models significantly reduces the number of errors in the performed task without any difference in completion time. Moreover, both models are perceived as useful, and the proactive active-learning based model has a slightly higher preference regarding the users' confidence in the result.},
  language = {en},
  booktitle = {Proceedings of the 28th {{Annual ACM Symposium}} on {{User Interface Software}} \& {{Technology}} - {{UIST}} '15},
  publisher = {{ACM Press}},
  doi = {10.1145/2807442.2807459},
  author = {Mayer, Mika{\"e}l and Soares, Gustavo and Grechkin, Maxim and Le, Vu and Marron, Mark and Polozov, Oleksandr and Singh, Rishabh and Zorn, Benjamin and Gulwani, Sumit},
  year = {2015},
  pages = {291-301},
  file = {/Users/geoffreylitt/Zotero/storage/GWGSLACW/Mayer et al. - 2015 - User Interaction Models for Disambiguation in Prog.pdf}
}

@article{huynh,
  title = {Potluck: {{Data Mash}}-{{Up Tool}} for {{Casual Users}}},
  abstract = {As more and more reusable structured data appears on the Web, casual users will want to take into their own hands the task of mashing up data rather than wait for mash-up sites to be built that address exactly their individually unique needs. In this paper, we present Potluck, a Web user interface that lets casual users\-\textemdash{}those without programming skills and data modeling expertise\textemdash{}mash up data themselves.},
  language = {en},
  author = {Huynh, David F and Miller, Robert C and Karger, David R},
  pages = {14},
  file = {/Users/geoffreylitt/Zotero/storage/8NYBXRL6/Huynh et al. - Potluck Data Mash-Up Tool for Casual Users.pdf}
}

@misc{zotero-48,
  title = {Exhibit | {{Proceedings}} of the 16th International Conference on {{World Wide Web}}},
  language = {en},
  howpublished = {http://dl.acm.org/doi/abs/10.1145/1242572.1242672},
  file = {/Users/geoffreylitt/Zotero/storage/6KKT6UT4/1242572.html}
}

@inproceedings{huynh2007,
  address = {{Banff, Alberta, Canada}},
  title = {Exhibit: Lightweight Structured Data Publishing},
  isbn = {978-1-59593-654-7},
  shorttitle = {Exhibit},
  abstract = {The early Web was hailed for giving individuals the same publishing power as large content providers. But over time, large content providers learned to exploit the structure in their data, leveraging databases and server side technologies to provide rich browsing and visualization. Individual authors fall behind once more: neither old-fashioned static pages nor domain-specific publishing frameworks supporting limited customization can match custom database-backed web applications.},
  language = {en},
  booktitle = {Proceedings of the 16th International Conference on {{World Wide Web}}  - {{WWW}} '07},
  publisher = {{ACM Press}},
  doi = {10.1145/1242572.1242672},
  author = {Huynh, David F. and Karger, David R. and Miller, Robert C.},
  year = {2007},
  pages = {737},
  file = {/Users/geoffreylitt/Zotero/storage/KDFB58RI/Huynh et al. - 2007 - Exhibit lightweight structured data publishing.pdf}
}

@inproceedings{huynh2006,
  address = {{Montreux, Switzerland}},
  title = {Enabling Web Browsers to Augment Web Sites' Filtering and Sorting Functionalities},
  isbn = {978-1-59593-313-3},
  abstract = {Existing augmentations of web pages are mostly small cosmetic changes (e.g., removing ads) and minor addition of third-party content (e.g., product prices from competing sites). None leverages the structured data presented in web pages. This paper describes Sifter, a web browser extension that can augment a well-structured web site with advanced filtering and sorting functionality. These added features work inside the site's own pages, preserving the site's presentational style and the user's context. Sifter contains an algorithm that scrapes structured data out of well-structured web pages while usually requiring no user intervention. We tested Sifter on real web sites and real users and found that people could use Sifter to perform sophisticated queries and high-level analyses on sizable data collections on the Web. We propose that web sites can be similarly augmented with other sophisticated data-centric functionality, giving users new benefits over the existing Web.},
  language = {en},
  booktitle = {Proceedings of the 19th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '06},
  publisher = {{ACM Press}},
  doi = {10.1145/1166253.1166274},
  author = {Huynh, David F. and Miller, Robert C. and Karger, David R.},
  year = {2006},
  pages = {125},
  file = {/Users/geoffreylitt/Zotero/storage/8WA9RXE3/Huynh et al. - 2006 - Enabling web browsers to augment web sites' filter.pdf}
}

@inproceedings{wong2007,
  address = {{San Jose, California, USA}},
  title = {Making Mashups with Marmite: Towards End-User Programming for the Web},
  isbn = {978-1-59593-593-9},
  shorttitle = {Making Mashups with Marmite},
  abstract = {There is a tremendous amount of web content available today, but it is not always in a form that supports end-users' needs. In many cases, all of the data and services needed to accomplish a goal already exist, but are not in a form amenable to an end-user. To address this problem, we have developed an end-user programming tool called Marmite, which lets end-users create so-called mashups that repurpose and combine existing web content and services. In this paper, we present the design, implementation, and evaluation of Marmite. An informal user study found that programmers and some spreadsheet users had little difficulty using the system.},
  language = {en},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}  - {{CHI}} '07},
  publisher = {{ACM Press}},
  doi = {10.1145/1240624.1240842},
  author = {Wong, Jeffrey and Hong, Jason I.},
  year = {2007},
  pages = {1435-1444},
  file = {/Users/geoffreylitt/Zotero/storage/9QWLY8KD/Wong and Hong - 2007 - Making mashups with marmite towards end-user prog.pdf}
}

@article{huynha,
  title = {Piggy {{Bank}}: {{Experience}} the {{Semantic Web Inside Your Web Browser}}},
  abstract = {The Semantic Web Initiative envisions a Web wherein information is offered free of presentation, allowing more effective exchange and mixing across web sites and across web pages. But without substantial Semantic Web content, few tools will be written to consume it; without many such tools, there is little appeal to publish Semantic Web content.},
  language = {en},
  author = {Huynh, David and Mazzocchi, Stefano and Karger, David},
  pages = {15},
  file = {/Users/geoffreylitt/Zotero/storage/KN75YT2E/Huynh et al. - Piggy Bank Experience the Semantic Web Inside You.pdf}
}

@inproceedings{huynh2005,
  address = {{Berlin, Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Piggy {{Bank}}: {{Experience}} the {{Semantic Web Inside Your Web Browser}}},
  isbn = {978-3-540-32082-1},
  shorttitle = {Piggy {{Bank}}},
  abstract = {The Semantic Web Initiative envisions a Web wherein information is offered free of presentation, allowing more effective exchange and mixing across web sites and across web pages. But without substantial Semantic Web content, few tools will be written to consume it; without many such tools, there is little appeal to publish Semantic Web content.To break this chicken-and-egg problem, thus enabling more flexible informa-tion access, we have created a web browser extension called Piggy Bankthat lets users make use of Semantic Web content within Web content as users browse the Web. Wherever Semantic Web content is not available, Piggy Bank can invoke screenscrapers to re-structure information within web pages into Semantic Web format. Through the use of Semantic Web technologies, Piggy Bank provides direct, immediate benefits to users in their use of the existing Web. Thus, the ex-istence of even just a few Semantic Web-enabled sites or a few scrapers already benefits users. Piggy Bank thereby offers an easy, incremental upgrade path to users without requiring a wholesale adoption of the Semantic Web's vision.To further improve this Semantic Web experience, we have created Semantic Bank, a web server application that lets Piggy Bank users share the Semantic Web information they have collected, enabling collaborative efforts to build so-phisticated Semantic Web information repositories through simple, everyday's use of Piggy Bank.},
  language = {en},
  booktitle = {The {{Semantic Web}} \textendash{} {{ISWC}} 2005},
  publisher = {{Springer}},
  doi = {10.1007/11574620_31},
  author = {Huynh, David and Mazzocchi, Stefano and Karger, David},
  editor = {Gil, Yolanda and Motta, Enrico and Benjamins, V. Richard and Musen, Mark A.},
  year = {2005},
  keywords = {Common Data Model,Information Item,Resource Description Framework,Resource Description Framework Data,Temporary Database},
  pages = {413-430},
  file = {/Users/geoffreylitt/Zotero/storage/T84CAZ7L/Huynh et al. - 2005 - Piggy Bank Experience the Semantic Web Inside You.pdf}
}

@inproceedings{hogue2005,
  address = {{Chiba, Japan}},
  title = {Thresher: Automating the Unwrapping of Semantic Content from the {{World Wide Web}}},
  isbn = {978-1-59593-046-0},
  shorttitle = {Thresher},
  abstract = {We describe Thresher, a system that lets non-technical users teach their browsers how to extract semantic web content from HTML documents on the World Wide Web. Users specify examples of semantic content by highlighting them in a web browser and describing their meaning. We then use the tree edit distance between the DOM subtrees of these examples to create a general pattern, or wrapper, for the content, and allow the user to bind RDF classes and predicates to the nodes of these wrappers. By overlaying matches to these patterns on standard documents inside the Haystack semantic web browser, we enable a rich semantic interaction with existing web pages, ``unwrapping'' semantic data buried in the pages' HTML. By allowing end-users to create, modify, and utilize their own patterns, we hope to speed adoption and use of the Semantic Web and its applications.},
  language = {en},
  booktitle = {Proceedings of the 14th International Conference on {{World Wide Web}}  - {{WWW}} '05},
  publisher = {{ACM Press}},
  doi = {10.1145/1060745.1060762},
  author = {Hogue, Andrew and Karger, David},
  year = {2005},
  pages = {86},
  file = {/Users/geoffreylitt/Zotero/storage/SGZ4PK28/Hogue and Karger - 2005 - Thresher automating the unwrapping of semantic co.pdf}
}

@incollection{miller2010a,
  address = {{Boston}},
  title = {Chapter 3 - {{Rewriting}} the {{Web}} with {{Chickenfoot}}},
  isbn = {978-0-12-381541-5},
  abstract = {Unlike desktop applications, Web applications are much more exposed and open to modification. This chapter describes Chickenfoot, a programming system embedded in the Firefox Web browser, which enables end users to automate, customize, and integrate Web applications without examining their source code. One way Chickenfoot addresses this goal is a technique for identifying page components by keyword pattern matching. Web automation includes navigating pages, filling in forms, and clicking on links. For example, many conferences now use a Web site to receive papers, distribute them to reviewers, and collect the reviews. A reviewer assigned 10 papers must download each paper, print it, and (later) upload a review for it. Tedious repetition is a good argument for automation. While integrating multiple Web sites, the simplest kind of integration is just adding links from one site to another, but much richer integration is possible. Techniques are developed through studying how users name Web page components and present a heuristic keyword-matching algorithm that identifies the desired component from the user's name. It describes a range of applications that have been created using Chickenfoot and reflects on its advantages and limitations.},
  language = {en},
  booktitle = {No {{Code Required}}},
  publisher = {{Morgan Kaufmann}},
  doi = {10.1016/B978-0-12-381541-5.00003-1},
  author = {Miller, Robert C. and Bolin, Michael and Chilton, Lydia B. and Little, Greg and Webber, Matthew and Yu, Chen-Hsiang},
  editor = {Cypher, Allen and Dontcheva, Mira and Lau, Tessa and Nichols, Jeffrey},
  month = jan,
  year = {2010},
  pages = {39-63},
  file = {/Users/geoffreylitt/Zotero/storage/ZZS3B7D7/Miller et al. - 2010 - Chapter 3 - Rewriting the Web with Chickenfoot.pdf;/Users/geoffreylitt/Zotero/storage/I95VQQIL/B9780123815415000031.html}
}

@incollection{little2010,
  title = {Sloppy Programming},
  isbn = {978-0-12-381541-5},
  abstract = {Modern applications provide interfaces for scripting, but many users do not know how to write script commands. However, many users are familiar with the idea of entering keywords into a Web search engine. Hence, if a user is familiar with the vocabulary of an application domain, we anticipate that they could write a set of keywords expressing a command in that domain. For instance, in the Web browsing domain, a user might enter ``click search button''. We call loosely grammatical commands of this sort ``sloppy commands.'' We discuss several prototypes that implement sloppy programming, translating sloppy commands directly into executable code. We also discuss the algorithms used in these prototypes, expose their limitations, and propose directions for future work.},
  language = {en},
  booktitle = {No {{Code Required}}},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00015-8},
  author = {Little, Greg and Miller, Robert C. and Chou, Victoria H. and Bernstein, Michael and Lau, Tessa and Cypher, Allen},
  year = {2010},
  pages = {289-307},
  file = {/Users/geoffreylitt/Zotero/storage/GBFFTC6G/Little et al. - 2010 - Sloppy programming.pdf}
}

@article{disessa1986,
  title = {Boxer: A Reconstructible Computational Medium},
  volume = {29},
  issn = {00010782},
  shorttitle = {Boxer},
  language = {en},
  number = {9},
  journal = {Communications of the ACM},
  doi = {10.1145/6592.6595},
  author = {{diSessa}, A. A and Abelson, H.},
  month = sep,
  year = {1986},
  pages = {859-868},
  file = {/Users/geoffreylitt/Zotero/storage/EWBMP8Z2/diSessa and Abelson - 1986 - Boxer a reconstructible computational medium.pdf}
}

@article{hypercard2019,
  title = {{{HyperCard}}},
  copyright = {Creative Commons Attribution-ShareAlike License},
  abstract = {HyperCard is a software application and  development kit for Apple Macintosh and Apple IIGS computers. It is among the first successful hypermedia systems predating the World Wide Web.
HyperCard combines a flat-file database with a graphical, flexible, user-modifiable interface. HyperCard includes a built-in programming language called HyperTalk for manipulating data and the user interface.
This combination of features \textendash{} a database with simple form layout, flexible support for graphics, and ease of programming \textendash{} suits HyperCard for many different projects such as rapid application development of applications and databases, interactive applications with no database requirements, command and control systems, and many examples in the demoscene.
HyperCard was originally released in 1987 for \$49.95 and was included for free with all new Macs sold then. It was withdrawn from sale in March 2004, having received its final update in 1998 upon the return of Steve Jobs to Apple. HyperCard runs in the Classic Environment, but was not ported to Mac OS X.},
  language = {en},
  journal = {Wikipedia},
  author = {Hypercard},
  month = dec,
  year = {2019},
  file = {/Users/geoffreylitt/Zotero/storage/XZV548R8/index.html},
  note = {Page Version ID: 931376685}
}

@misc{victor,
  title = {Dynamicland},
  abstract = {incubating a humane dynamic medium},
  howpublished = {https://dynamicland.org/},
  author = {Victor, Bret},
  file = {/Users/geoffreylitt/Zotero/storage/JIP78YH7/dynamicland.org.html}
}

@inproceedings{verou2016,
  address = {{Tokyo, Japan}},
  title = {Mavo: {{Creating Interactive Data}}-{{Driven Web Applications}} by {{Authoring HTML}}},
  isbn = {978-1-4503-4189-9},
  shorttitle = {Mavo},
  abstract = {Many people can author static web pages with HTML and CSS but find it hard or impossible to program persistent, interactive web applications. We show that for a broad class of CRUD (Create, Read, Update, Delete) applications, this gap can be bridged. Mavo extends the declarative syntax of HTML to describe Web applications that manage, store and transform data. Using Mavo, authors with basic HTML knowledge define complex data schemas implicitly as they design their HTML layout. They need only add a few attributes and expressions to their HTML elements to transform their static design into a persistent, data-driven web application whose data can be edited by direct manipulation of the content in the browser. We evaluated Mavo with 20 users who marked up static designs\textemdash{}some provided by us, some their own creation\textemdash{}to transform them into fully functional web applications. Even users with no programming experience were able to quickly craft Mavo applications.},
  language = {en},
  booktitle = {Proceedings of the 29th {{Annual Symposium}} on {{User Interface Software}} and {{Technology}} - {{UIST}} '16},
  publisher = {{ACM Press}},
  doi = {10.1145/2984511.2984551},
  author = {Verou, Lea and Zhang, Amy X. and Karger, David R.},
  year = {2016},
  pages = {483-496},
  file = {/Users/geoffreylitt/Zotero/storage/WDIPZUY3/Verou et al. - 2016 - Mavo Creating Interactive Data-Driven Web Applica.pdf}
}

@inproceedings{chang2014,
  address = {{Honolulu, Hawaii, USA}},
  title = {Creating Interactive Web Data Applications with Spreadsheets},
  isbn = {978-1-4503-3069-5},
  abstract = {While more and more data are available through web services, it remains difficult for end-users to create web applications that make use of these data without having to write complex code. We present Gneiss, a live programming environment that extends the spreadsheet metaphor to support creating interactive web applications that dynamically use local and web data from multiple sources. Gneiss closely integrates a spreadsheet editor with a web interface builder to let users demonstrate bindings between properties of web GUI elements and cells in the spreadsheet while working with real web service data. The spreadsheet editor provides two-way connections to web services, to both visualize and retrieve different data based on the user input in the web interface. Gneiss achieves rich interactivity without the need for event-based programming by extending the ``pull model'' of formulas that is familiar to the spreadsheet users. We use a series of examples to demonstrate Gneiss's ability to create a variety of interactive web data applications.},
  language = {en},
  booktitle = {Proceedings of the 27th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '14},
  publisher = {{ACM Press}},
  doi = {10.1145/2642918.2647371},
  author = {Chang, Kerry Shih-Ping and Myers, Brad A.},
  year = {2014},
  pages = {87-96},
  file = {/Users/geoffreylitt/Zotero/storage/VKRPDATE/Chang and Myers - 2014 - Creating interactive web data applications with sp.pdf}
}

@misc{zotero-79,
  title = {Airtable: {{Organize}} Anything You Can Imagine},
  shorttitle = {Airtable},
  abstract = {Airtable works like a spreadsheet but gives you the power of a database to organize anything. Sign up for free.},
  journal = {Airtable},
  howpublished = {https://airtable.com},
  file = {/Users/geoffreylitt/Zotero/storage/8UKHXPNG/airtable.com.html}
}

@misc{zotero-81,
  title = {Create an {{App}} from a {{Google Sheet}} in {{Minutes}} {$\cdot$} {{Glide}}},
  abstract = {Glide turns spreadsheets into beautiful, easy-to-use apps, without code. Pick a spreadsheet or start with a template, customize your app, then share it instantly with anyone. Start today for free!},
  language = {en},
  howpublished = {https://www.glideapps.com/},
  file = {/Users/geoffreylitt/Zotero/storage/YRRWLQM8/www.glideapps.com.html}
}

@inproceedings{benson2014,
  address = {{Honolulu, Hawaii, USA}},
  title = {Spreadsheet Driven Web Applications},
  isbn = {978-1-4503-3069-5},
  abstract = {Creating and publishing read-write-compute web applications requires programming skills beyond what most end users possess. But many end users know how to make spreadsheets that act as simple information management applications, often with computation. We present a system for creating basic web applications using such spreadsheets in place of a server and using HTML to describe the client UI. Authors connect the two by placing spreadsheet references inside HTML attributes. Data computation is provided by spreadsheet formulas. The result is a reactive read-write-compute web page without a single line of Javascript code. Nearly all of the fifteen HTML novices we studied were able to connect HTML to spreadsheets using our method with minimal instruction. We draw conclusions from their experience and discuss future extensions to this programming model.},
  language = {en},
  booktitle = {Proceedings of the 27th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '14},
  publisher = {{ACM Press}},
  doi = {10.1145/2642918.2647387},
  author = {Benson, Edward and Zhang, Amy X. and Karger, David R.},
  year = {2014},
  pages = {97-106},
  file = {/Users/geoffreylitt/Zotero/storage/GGLIRAZC/Benson et al. - 2014 - Spreadsheet driven web applications.pdf}
}

@inproceedings{chasins2018,
  address = {{Berlin, Germany}},
  title = {Rousillon: {{Scraping Distributed Hierarchical Web Data}}},
  isbn = {978-1-4503-5948-1},
  shorttitle = {Rousillon},
  abstract = {Programming by Demonstration (PBD) promises to enable data scientists to collect web data. However, in formative interviews with social scientists, we learned that current PBD tools are insufficient for many real-world web scraping tasks. The missing piece is the capability to collect hierarchicallystructured data from across many different webpages. We present Rousillon, a programming system for writing complex web automation scripts by demonstration. Users demonstrate how to collect the first row of a `universal table' view of a hierarchical dataset to teach Rousillon how to collect all rows. To offer this new demonstration model, we developed novel relation selection and generalization algorithms. In a withinsubject user study on 15 computer scientists, users can write hierarchical web scrapers 8 times more quickly with Rousillon than with traditional programming.},
  language = {en},
  booktitle = {The 31st {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}} - {{UIST}} '18},
  publisher = {{ACM Press}},
  doi = {10.1145/3242587.3242661},
  author = {Chasins, Sarah E. and Mueller, Maria and Bodik, Rastislav},
  year = {2018},
  pages = {963-975},
  file = {/Users/geoffreylitt/Zotero/storage/DJQ79QKU/Chasins et al. - 2018 - Rousillon Scraping Distributed Hierarchical Web D.pdf}
}


