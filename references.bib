
@inproceedings{bolin2005,
  address = {{Seattle, WA, USA}},
  title = {Automation and Customization of Rendered Web Pages},
  isbn = {978-1-59593-271-6},
  abstract = {On the desktop, an application can expect to control its user interface down to the last pixel, but on the World Wide Web, a content provider has no control over how the client will view the page, once delivered to the browser. This creates an opportunity for end-users who want to automate and customize their web experiences, but the growing complexity of web pages and standards prevents most users from realizing this opportunity. We describe Chickenfoot, a programming system embedded in the Firefox web browser, which enables end-users to automate, customize, and integrate web applications without examining their source code. One way Chickenfoot addresses this goal is a novel technique for identifying page components by keyword pattern matching. We motivate this technique by studying how users name web page components, and present a heuristic keyword matching algorithm that identifies the desired component from the user's name.},
  language = {en},
  booktitle = {Proceedings of the 18th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology  - {{UIST}} '05},
  publisher = {{ACM Press}},
  doi = {10.1145/1095034.1095062},
  author = {Bolin, Michael and Webber, Matthew and Rha, Philip and Wilson, Tom and Miller, Robert C.},
  year = {2005},
  keywords = {Wildcard},
  pages = {163},
  file = {/Users/geoffreylitt/Zotero/storage/JS89G2G2/Bolin et al. - 2005 - Automation and customization of rendered web pages.pdf}
}

@inproceedings{miller2010,
  title = {Rewriting the {{Web}} with {{Chickenfoot}}},
  abstract = {Publisher Summary Unlike desktop applications, Web applications are much more exposed and open to modification. This chapter describes Chickenfoot, a programming system embedded in the Firefox Web browser, which enables end users to automate, customize, and integrate Web applications without examining their source code. One way Chickenfoot addresses this goal is a technique for identifying page components by keyword pattern matching. Web automation includes navigating pages, filling in forms, and clicking on links. For example, many conferences now use a Web site to receive papers, distribute them to reviewers, and collect the reviews. A reviewer assigned 10 papers must download each paper, print it, and (later) upload a review for it. Tedious repetition is a good argument for automation. While integrating multiple Web sites, the simplest kind of integration is just adding links from one site to another, but much richer integration is possible. Techniques are developed through studying how users name Web page components and present a heuristic keyword-matching algorithm that identifies the desired component from the user's name. It describes a range of applications that have been created using Chickenfoot and reflects on its advantages and limitations.},
  doi = {10.1016/B978-0-12-381541-5.00003-1},
  author = {Miller, Robert C. and Bolin, Michael and Chilton, Lydia B. and Little, Greg and Webber, Matthew J. and Yu, Chen-Hsiang},
  year = {2010},
  keywords = {Desktop computer,HTML,HTTP,Human-readable medium,Internet,Rewriting,Sprout (computer),User Interface Device Component,Web application,World Wide Web,XML,Wildcard}
}

@book{disessa2000,
  address = {{Cambridge, MA, USA}},
  title = {Changing {{Minds}}: {{Computers}}, {{Learning}}, and {{Literacy}}},
  shorttitle = {Changing {{Minds}}},
  publisher = {{MIT Press}},
  author = {{diSessa}, Andrea A.},
  year = {2000}
}

@inproceedings{leshed2008,
  address = {{New York, NY, USA}},
  series = {{{CHI}} '08},
  title = {{{CoScripter}}: {{Automating}} \& {{Sharing How}}-to {{Knowledge}} in the {{Enterprise}}},
  isbn = {978-1-60558-011-1},
  shorttitle = {{{CoScripter}}},
  abstract = {Modern enterprises are replete with numerous online processes. Many must be performed frequently and are tedious, while others are done less frequently yet are complex or hard to remember. We present interviews with knowledge workers that reveal a need for mechanisms to automate the execution of and to share knowledge about these processes. In response, we have developed the CoScripter system (formerly Koala [11]), a collaborative scripting environment for recording, automating, and sharing web-based processes. We have deployed CoScripter within a large corporation for more than 10 months. Through usage log analysis and interviews with users, we show that CoScripter has addressed many user automation and sharing needs, to the extent that more than 50 employees have voluntarily incorporated it into their work practice. We also present ways people have used CoScripter and general issues for tools that support automation and sharing of how-to knowledge.},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  publisher = {{ACM}},
  doi = {10.1145/1357054.1357323},
  author = {Leshed, Gilly and Haber, Eben M. and Matthews, Tara and Lau, Tessa},
  year = {2008},
  keywords = {automation,knowledge sharing,procedural knowledge,programming-by-demonstration,scripting,user study,wiki},
  pages = {1719--1728},
  file = {/Users/geoffreylitt/Zotero/storage/RHE55DIG/Leshed et al. - 2008 - CoScripter Automating & Sharing How-to Knowledge .pdf}
}

@misc{talwar2019,
  title = {Gmail.Js},
  abstract = {Gmail JavaScript API},
  language = {en},
  journal = {GitHub},
  howpublished = {https://github.com/KartikTalwar/gmail.js},
  author = {Talwar, Kartik},
  year = {2019},
  file = {/Users/geoffreylitt/Zotero/storage/EQIGCWJM/master.html}
}

@misc{streak,
  title = {{{InboxSDK}}},
  howpublished = {https://www.inboxsdk.com/},
  author = {Streak},
  file = {/Users/geoffreylitt/Zotero/storage/TK2FCLM5/www.inboxsdk.com.html}
}

@misc{inkandswitch2019,
  title = {End-User Programming},
  abstract = {A vision for empowered computing that reaches back forty years. Our research lab examines why it has been so hard to achieve.},
  language = {en-US},
  journal = {Ink and Switch},
  author = {{Ink {and} Switch}},
  month = mar,
  year = {2019},
  file = {/Users/geoffreylitt/Zotero/storage/VN9ZZWVZ/end-user-programming.html}
}

@inproceedings{beaudouin-lafon2000,
  address = {{New York, NY, USA}},
  series = {{{AVI}} '00},
  title = {Reification, {{Polymorphism}} and {{Reuse}}: {{Three Principles}} for {{Designing Visual Interfaces}}},
  isbn = {978-1-58113-252-6},
  shorttitle = {Reification, {{Polymorphism}} and {{Reuse}}},
  abstract = {This paper presents three design principles to support the development of large-scale applications and take advantage of recent research in new interaction techniques: Reification turns concepts into first class objects, polymorphism permits commands to be applied to objects of different types, and reuse makes both user input and system output accessible for later use. We show that the power of these principles lies in their combination. Reification creates new objects that can be acted upon by a small set of polymorphic commands, creating more opportunities for reuse. The result is a simpler yet more powerful interface.
To validate these principles, we describe their application in the redesign of a complex interface for editing and simulating Coloured Petri Nets. The cpn2000 interface integrates floating palettes, toolglasses and marking menus in a consistent manner with a new metaphor for managing the workspace. It challenges traditional ideas about user interfaces, getting rid of pull-down menus, scrollbars, and even selection, while providing the same or greater functionality. Preliminary tests with users show that they find the new system both easier to use and more efficient.},
  booktitle = {Proceedings of the {{Working Conference}} on {{Advanced Visual Interfaces}}},
  publisher = {{ACM}},
  doi = {10.1145/345513.345267},
  author = {{Beaudouin-Lafon}, Michel and Mackay, Wendy E.},
  year = {2000},
  keywords = {design principles,direct manipulation,instrumental interaction,interaction model,polymorphism,reification,reuse},
  pages = {102--109},
  file = {/Users/geoffreylitt/Zotero/storage/ZUTWDQ9X/Beaudouin-Lafon and Mackay - 2000 - Reification, Polymorphism and Reuse Three Princip.pdf}
}

@misc{berners-lee2018,
  title = {One {{Small Step}} for the {{Web}}\ldots{}},
  abstract = {I've always believed the web is for everyone. That's why I and others fight fiercely to protect it. The changes we've managed to bring have\ldots{}},
  language = {en},
  journal = {Medium},
  howpublished = {https://medium.com/@timberners\_lee/one-small-step-for-the-web-87f92217d085},
  author = {{Berners-Lee}, Tim},
  month = sep,
  year = {2018},
  file = {/Users/geoffreylitt/Zotero/storage/MSSQR3BL/one-small-step-for-the-web-87f92217d085.html}
}

@inproceedings{klokmose2015,
  address = {{Daegu, Kyungpook, Republic of Korea}},
  title = {Webstrates: {{Shareable Dynamic Media}}},
  isbn = {978-1-4503-3779-3},
  shorttitle = {Webstrates},
  abstract = {We revisit Alan Kay's early vision of dynamic media that blurs the distinction between documents and applications. We introduce shareable dynamic media that are malleable by users, who may appropriate them in idiosyncratic ways; shareable among users, who collaborate on multiple aspects of the media; and distributable across diverse devices and platforms. We present Webstrates, an environment for exploring shareable dynamic media. Webstrates augment web technology with real-time sharing. They turn web pages into substrates, i.e. software entities that act as applications or documents depending upon use. We illustrate Webstrates with two implemented case studies: users collaboratively author an article with functionally and visually different editors that they can personalize and extend at run-time; and they orchestrate its presentation and audience participation with multiple devices. We demonstrate the simplicity and generative power of Webstrates with three additional prototypes and evaluate it from a systems perspective.},
  language = {en},
  booktitle = {Proceedings of the 28th {{Annual ACM Symposium}} on {{User Interface Software}} \& {{Technology}} - {{UIST}} '15},
  publisher = {{ACM Press}},
  doi = {10.1145/2807442.2807446},
  author = {Klokmose, Clemens N. and Eagan, James R. and Baader, Siemen and Mackay, Wendy and {Beaudouin-Lafon}, Michel},
  year = {2015},
  pages = {280-290},
  file = {/Users/geoffreylitt/Zotero/storage/PZI6XAMQ/Klokmose et al. - 2015 - iWebstratesi Shareable Dynamic Media.pdf}
}

@article{kay1977,
  title = {Personal {{Dynamic Media}}},
  volume = {10},
  issn = {1558-0814},
  abstract = {The Learning Research Group at Xerox Palo Alto Research Center is concerned with all aspects of the communication and manipulation of knowledge. We design, build, and use dynamic media which can be used by human beings of all ages. Several years ago, we crystallized our dreams into a design idea for a personal dynamic medium the size of a notebook (the Dynabook) which could be owned by everyone and could have the power to handle virtually all of its owner's information-related needs. Towards this goal we have designed and built a communications system: the Smalltalk language, implemented on small computers we refer to as "interim Dynabooks." We are exploring the use of this system as a programming and problem solving tool; as an interactive memory for the storage and manipulation of data; as a text editor; and as a medium for expression through drawing, painting, animating pictures, and composing and generating music. (Figure 1 is a view of this interim Dynabook.)},
  number = {3},
  journal = {Computer},
  doi = {10.1109/C-M.1977.217672},
  author = {Kay, A. and Goldberg, A.},
  month = mar,
  year = {1977},
  keywords = {Animation,Computational modeling,Crystallization,Embedded computing,Information retrieval,Manipulator dynamics,Problem-solving},
  pages = {31-41},
  file = {/Users/geoffreylitt/Zotero/storage/Q3SGCHYI/Kay and Goldberg - 1977 - Personal Dynamic Media.pdf;/Users/geoffreylitt/Zotero/storage/8Q36BUGB/1646405.html}
}

@article{chang2019,
  title = {Dependent Type Systems as Macros},
  volume = {4},
  issn = {24751421},
  language = {en},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  doi = {10.1145/3371071},
  author = {Chang, Stephen and Ballantyne, Michael and Turner, Milo and Bowman, William J.},
  month = dec,
  year = {2019},
  keywords = {toread},
  pages = {1-29},
  file = {/Users/geoffreylitt/Zotero/storage/DL7ZUBWU/Chang et al. - 2019 - Dependent type systems as macros.pdf}
}

@article{lew2019,
  title = {Trace Types and Denotational Semantics for Sound Programmable Inference in Probabilistic Languages},
  volume = {4},
  issn = {24751421},
  abstract = {ALEXANDER K. LEW, Massachusetts Institute of Technology, USA MARCO F. CUSUMANO-TOWNER, Massachusetts Institute of Technology, USA BENJAMIN SHERMAN, Massachusetts Institute of Technology, USA MICHAEL CARBIN, Massachusetts Institute of Technology, USA VIKASH K. MANSINGHKA, Massachusetts Institute of Technology, USA Modern probabilistic programming languages aim to formalize and automate key aspects of probabilistic modeling and inference. Many languages provide constructs for programmable inference that enable developers 19 to improve inference speed and accuracy by tailoring an algorithm for use with a particular model or dataset. Unfortunately, it is easy to use these constructs to write unsound programs that appear to run correctly but produce incorrect results. To address this problem, we present a denotational semantics for programmable inference in higher-order probabilistic programming languages, along with a type system that ensures that well-typed inference programs are sound by construction. A central insight is that the type of a probabilistic expression can track the space of its possible execution traces, not just the type of value that it returns, as these traces are often the objects that inference algorithms manipulate. We use our semantics and type system to establish soundness properties of custom inference programs that use constructs for variational, sequential Monte Carlo, importance sampling, and Markov chain Monte Carlo inference. CCS Concepts: {$\cdot$} Mathematics of computing \textrightarrow{} Probabilistic inference problems; Variational methods; Metropolis-Hastings algorithm; Sequential Monte Carlo methods; {$\cdot$} Theory of computation \textrightarrow{} Semantics and reasoning; Denotational semantics; {$\cdot$} Software and its engineering \textrightarrow{} Formal language definitions.},
  language = {en},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  doi = {10.1145/3371087},
  author = {Lew, Alexander K. and {Cusumano-Towner}, Marco F. and Sherman, Benjamin and Carbin, Michael and Mansinghka, Vikash K.},
  month = dec,
  year = {2019},
  keywords = {toread},
  pages = {1-32},
  file = {/Users/geoffreylitt/Zotero/storage/RTHTYZ7Y/Lew et al. - 2019 - Trace types and denotational semantics for sound p.pdf}
}

@article{wang2019,
  title = {Visualization by Example},
  volume = {4},
  issn = {24751421},
  abstract = {CHENGLONG WANG, University of Washington, USA YU FENG, University of California, Santa Barbara, USA RASTISLAV BODIK, University of Washington, USA ALVIN CHEUNG, University of California, Berkeley, USA ISIL DILLIG, University of Texas at Austin, USA While visualizations play a crucial role in gaining insights from data, generating useful visualizations from a complex dataset is far from an easy task. In particular, besides understanding the functionality provided by existing visualization libraries, generating the desired visualization also requires reshaping and aggregating the underlying data as well as composing different visual elements to achieve the intended visual narrative. This paper aims to simplify visualization tasks by automatically synthesizing the required program from simple visual sketches provided by the user. Specifically, given an input data set and a visual sketch that demonstrates how to visualize a very small subset of this data, our technique automatically generates a program that can be used to visualize the entire data set. From a program synthesis perspective, automating visualization tasks poses several challenges that are not addressed by prior techniques. First, because many visualization tasks require data wrangling in addition to generating plots from a given table, we need to decompose the end-to-end synthesis task into two separate sub-problems. Second, because the intermediate specification that results from the decomposition is necessarily imprecise, this makes the data wrangling task particularly challenging in our context. In this paper, we address these problems by developing a new compositional visualization-by-example technique that (a) decomposes the end-to-end task into two different synthesis problems over different DSLs and (b) leverages bi-directional program analysis to deal with the complexity that arises from having an imprecise intermediate specification. We have implemented our visualization-by-example approach in a tool called Viser and evaluate it on 83 visualization tasks collected from on-line forums and tutorials. Viser can solve 84\% of these benchmarks within a 600 second time limit, and, for those tasks that can be solved, the desired visualization is among the top-5 generated by Viser in 70\% of the cases. CCS Concepts: \textbullet{} Theory of computation \textrightarrow{} Program reasoning; \textbullet{} Human-centered computing \textrightarrow{} Visualization toolkits.},
  language = {en},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  doi = {10.1145/3371117},
  author = {Wang, Chenglong and Feng, Yu and Bodik, Rastislav and Cheung, Alvin and Dillig, Isil},
  month = dec,
  year = {2019},
  keywords = {toread},
  pages = {1-28},
  file = {/Users/geoffreylitt/Zotero/storage/2RWUSYKS/Wang et al. - 2019 - Visualization by example.pdf}
}

@article{ohearn2019,
  title = {Incorrectness Logic},
  volume = {4},
  issn = {24751421},
  abstract = {PETER W. O'HEARN, Facebook and University College London, UK 10 Program correctness and incorrectness are two sides of the same coin. As a programmer, even if you would like to have correctness, you might find yourself spending most of your time reasoning about incorrectness. This includes informal reasoning that people do while looking at or thinking about their code, as well as that supported by automated testing and static analysis tools. This paper describes a simple logic for program incorrectness which is, in a sense, the other side of the coin to Hoare's logic of correctness. CCS Concepts: {$\cdot$} Theory of computation \textrightarrow{} Programming logic.},
  language = {en},
  number = {POPL},
  journal = {Proceedings of the ACM on Programming Languages},
  doi = {10.1145/3371078},
  author = {O'Hearn, Peter W.},
  month = dec,
  year = {2019},
  keywords = {toread},
  pages = {1-32},
  file = {/Users/geoffreylitt/Zotero/storage/TDY592AI/O'Hearn - 2019 - Incorrectness logic.pdf}
}


